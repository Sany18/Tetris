<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Тетріс Sany18</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      display: flex;
      justify-content: center;
      min-height: 100vh;
    }

    #content {
      flex: 1;
      display: flex;
      justify-content: center;
      background: black;
    }
  </style>
</head>
<body>
  <div id="content">
    <canvas></canvas>
  </div>

  <script>
    window.onload = () => {
      const config = {
        backgroundColor: '#000',
        emptySquareColor: '#fff',
        activeSquareColor: '#f00',
        inactiveSquareColor: '#00f',
        width: 10,
        height: 16,
        squareSize: 20, // px
        spaceBetweenSquares: 1, // px
        gameSpeed: 1000, // ms
        redrawSpeed: 1000 / 60, // ms
        figures: [
          [
            [1, 1],
            [1, 1],
          ],
          [
            [1, 1, 1],
            [0, 1, 0],
          ],
          [
            [1, 1, 1],
            [0, 0, 1],
          ],
          [
            [1, 1, 1],
            [1, 0, 0],
          ],
          [
            [1, 1, 0],
            [0, 1, 1],
          ],
          [
            [0, 1, 1],
            [1, 1, 0],
          ],
          [
            [0, 1, 0],
            [1, 1, 1],
          ],
          [
            [1, 0, 0],
            [1, 1, 1],
          ],
          [
            [1, 1, 1, 1],
          ],
          [
            [1],
            [1],
            [1],
            [1],
          ],
          [
            [1],
          ]
        ]
      };

      const state = {
        filledElements: createEmptyMatrix(config.width, config.height),
        currentFigure: null, // { shape: [[1,1], [1,1]], position: {x,y}, rotation: 0, rotatedShape: [[1,1], [1,1]], firstPosition: true }
        lastTick: Date.now(),
        pause: false,
      }

      const canvas = document.querySelector('canvas');
      canvas.width = config.width * config.squareSize + config.spaceBetweenSquares * config.width;
      canvas.height = config.height * config.squareSize + config.spaceBetweenSquares * config.height;
      const ctx = canvas.getContext('2d');
      initEventListeners();

      const aciton = () => {
        if (state.pause) return;

        drawMesh();
        drawCurrentFigure();
        drawFallenFigures();

        if (Date.now() - state.lastTick > config.gameSpeed) {
          fallFigure();
          removeLines();
          state.lastTick = Date.now();
        }

        setTimeout(() => {
          requestAnimationFrame(aciton);
        }, config.redrawSpeed);
      };
      requestAnimationFrame(aciton);

      // key handlers
      function pressLeft() {
        if (canMoveLeft(state.currentFigure)) {
          --state.currentFigure.position.x;
        }
      }

      function pressRight() {
        if (canMoveRight(state.currentFigure)) {
          ++state.currentFigure.position.x;
        }
      }

      function pressDown() {
        if (canFall(state.currentFigure)) {
          ++state.currentFigure.position.y;
          state.currentFigure.firstPosition = false;
        }
      }

      function pressUp() {
        if (canRotate(state.currentFigure)) {
          state.currentFigure.rotation = (state.currentFigure.rotation + 1) % 4;
          state.currentFigure.rotatedShape = getRotatedShapeOfFigure(state.currentFigure);
        }
      }

      // drawing elements
      function removeLines() {
        for (let i = 0; i < config.height; i++) {
          if (state.filledElements.every(line => line[i] == 1)) {
            state.filledElements.forEach(line => line.splice(i, 1));
            state.filledElements.forEach(line => line.unshift(0));
          }
        }
      }

      function drawCurrentFigure() {
        if (state.currentFigure) drawFigure();
        if (!state.currentFigure) {
          const figure = getRandomFigure();
          const tl = Math.round((config.width - figure[0].length) / 2); // top left position of figure
          state.currentFigure = {
            shape: figure,
            position: { x: tl, y: 0 },
            rotation: 0,
            rotatedShape: figure,
            firstPosition: true
          };
          drawFigure();
        }
      }

      function drawFallenFigures() {
        for (let i = 0; i < config.width; i++) {
          for (let j = 0; j < config.height; j++) {
            if (state.filledElements[i][j] == 1) {
              drawSquare(i, j, config.inactiveSquareColor);
            }
          }
        }
      };

      function drawFigure() {
        const { x, y } = state.currentFigure.position;
        const { rotatedShape } = state.currentFigure;

        for (let i = 0; i < rotatedShape.length; i++) {
          for (let j = 0; j < rotatedShape[i].length; j++) {
            if (rotatedShape[i][j] == 1) {
              drawSquare(x + j, y + i, config.activeSquareColor);
            }
          }
        }
      }

      function drawSquare(_x, _y, color) {
        const size = config.squareSize;
        const { x, y } = getAbsolutePosition(_x, _y);
        ctx.fillStyle = color;
        ctx.fillRect(x, y, size, size);
      }

      function drawMesh() {
        for (let i = 0; i < config.width; i++) {
          for (let j = 0; j < config.height; j++) {
            drawSquare(i, j, config.emptySquareColor);
          }
        }
      }

      // calculations
      function fallFigure() {
        if (canFall(state.currentFigure)) {
          state.currentFigure.position.y++;
          state.currentFigure.firstPosition = false;
        } else {
          if (state.currentFigure.firstPosition) {
            state.pause = true;
            console.log('game over');
          }
          const coordinates = getFigureCoordinates(state.currentFigure);
          coordinates.forEach(({ x, y }) => state.filledElements[x][y] = 1);
          state.currentFigure = null;
        }
      }

      function canMoveLeft(figure) {
        if (!figure) return false;
        const coordinates = getFigureCoordinates(figure);
        return coordinates.every(({ x, y }) => {
          return state.filledElements[x - 1] && state.filledElements[x - 1][y] == 0;
        });
      }

      function canMoveRight(figure) {
        if (!figure) return false;
        const coordinates = getFigureCoordinates(figure);
        return coordinates.every(({ x, y }) => {
          return state.filledElements[x + 1] && state.filledElements[x + 1][y] == 0;
        });
      }

      function canFall(figure) {
        if (!figure) return false;
        let canFall = true;
        const coordinates = getFigureCoordinates(figure);
        coordinates.forEach(({ x, y }) => {
          if (y == config.height - 1) canFall = false;
          if (state.filledElements[x][y + 1] != 0) canFall = false;
        });
        return canFall;
      }

      function canRotate(figure) {
        if (!figure) return false;
        return true;
      }

      function getAbsolutePosition(x, y) {
        return {
          x: x * config.squareSize + config.spaceBetweenSquares * x,
          y: y * config.squareSize + config.spaceBetweenSquares * y,
        };
      }

      function createEmptyMatrix(width, height) {
        const a = [];
        for (let i = 0; i < width; i++) {
          const b = [];
          for (let j = 0; j < height; j++) {
            b.push(0);
          }
          a.push(b);
        }

        return a;
      }

      function getRandomFigure() {
        const index = Math.floor(Math.random() * config.figures.length);
        return config.figures[index];
      }

      function getFigureCoordinates(figure) {
        if (!figure) return [];
        const { x, y } = figure.position;
        const { rotatedShape } = figure;
        const coordinates = [];
        for (let i = 0; i < rotatedShape.length; i++) {
          for (let j = 0; j < rotatedShape[i].length; j++) {
            if (rotatedShape[i][j] == 1) {
              coordinates.push({ x: x + j, y: y + i });
            }
          }
        }

        return coordinates;
      }

      function getRotatedShapeOfFigure(figure) {
        const { shape, rotation } = figure;
        let rotatedShape = []

        if (rotation == 0) return shape;
        if (rotation == 1) {
          rotatedShape = createEmptyMatrix(shape[0].length, shape.length);

          for (let i = 0; i < shape.length; i++) {
            for (let j = 0; j < shape[i].length; j++) {
              rotatedShape[j][shape.length - 1 - i] = shape[i][j];
            }
          }
          return rotatedShape;
        }
        if (rotation == 2) {
          rotatedShape = createEmptyMatrix(shape.length, shape[0].length);

          for (let i = 0; i < shape.length; i++) {
            for (let j = 0; j < shape[i].length; j++) {
              rotatedShape[shape.length - 1 - i][shape[i].length - 1 - j] = shape[i][j];
            }
          }
          return rotatedShape;
        }
        if (rotation == 3) {
          rotatedShape = createEmptyMatrix(shape[0].length, shape.length);

          for (let i = 0; i < shape.length; i++) {
            for (let j = 0; j < shape[i].length; j++) {
              rotatedShape[shape[i].length - 1 - j][i] = shape[i][j];
            }
          }
          return rotatedShape;
        }

        return shape;
      }

      // event listeners
      function initEventListeners() {
        document.addEventListener('keydown', (e) => {
          if (e.key === 'ArrowLeft') {
            pressLeft(true);
          } else if (e.key === 'ArrowRight') {
            pressRight(true);
          } else if (e.key === 'ArrowDown') {
            pressDown(true);
          } else if (e.key === 'ArrowUp') {
            pressUp(true);
          }
        });
      }
    }
  </script>
</body>
</html>
